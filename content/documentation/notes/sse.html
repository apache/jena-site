<!DOCTYPE html>
<html lang="en">
<head>
    

    <title>Apache Jena - SPARQL S-Expressions (or &#34;SPARQL Syntax Expressions&#34;)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="/css/bootstrap.min.css" rel="stylesheet" media="screen">
    <link href="/css/bootstrap-extension.css" rel="stylesheet" type="text/css">
    <link href="/css/jena.css" rel="stylesheet" type="text/css">
    <link rel="shortcut icon" href="/images/favicon.ico" />

    <script src="https://code.jquery.com/jquery-2.2.4.min.js"
            integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="
            crossorigin="anonymous"></script>
    <script src="/js/jena-navigation.js" type="text/javascript"></script>
    <script src="/js/bootstrap.min.js" type="text/javascript"></script>

    <script src="/js/improve.js" type="text/javascript"></script>

    
</head>

<body>

<nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/index.html">
                <img class="logo-menu" src="/images/jena-logo/jena-logo-notext-small.png" alt="jena logo">Apache Jena</a>
        </div>

        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                <li id="homepage"><a href="/index.html"><span class="glyphicon glyphicon-home"></span> Home</a></li>
                <li id="download"><a href="/download/index.cgi"><span class="glyphicon glyphicon-download-alt"></span> Download</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown"><span class="glyphicon glyphicon-book"></span> Learn <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li class="dropdown-header">Tutorials</li>
                        <li><a href="/tutorials/index.html">Overview</a></li>
                        <li><a href="/tutorials/rdf_api.html">RDF core API tutorial</a></li>
                        <li><a href="/tutorials/sparql.html">SPARQL tutorial</a></li>
                        <li><a href="/documentation/query/manipulating_sparql_using_arq.html">Manipulating SPARQL using ARQ</a></li>
                        <li><a href="/tutorials/using_jena_with_eclipse.html">Using Jena with Eclipse</a></li>
                        <li><a href="/documentation/notes/index.html">How-To's</a></li>
                        <li class="divider"></li>
                        <li class="dropdown-header">References</li>
                        <li><a href="/documentation/index.html">Overview</a></li>
                        <li><a href="/documentation/javadoc.html">Javadoc</a></li>
                        <li><a href="/documentation/rdf/index.html">RDF API</a></li>
                        <li><a href="/documentation/io/">RDF I/O</a></li>
                        <li><a href="/documentation/fuseki2/index.html">Fuseki</a></li>
                        <li><a href="/documentation/query/index.html">ARQ (SPARQL)</a></li>
                        <li><a href="/documentation/rdfconnection/">RDF Connection - SPARQL API</a></li>
                        <li><a href="/documentation/rdfs/">Data with RDFS Inferencing</a></li>
                        <li><a href="/documentation/tdb/index.html">TDB</a></li>
                        <li><a href="/documentation/tdb2/index.html">TDB2</a></li>
                        <li><a href="/documentation/query/text-query.html">Text Search</a></li>
                        <li><a href="/documentation/shacl/index.html">SHACL</a></li>
                        <li><a href="/documentation/rdfstar/index.html">RDF-star</a></li>
                        <li><a href="/documentation/tools/index.html">Command-line tools</a></li>
                        <li><a href="/documentation/hadoop/index.html">Elephas - tools for RDF on Hadoop</a></li>
                        <li><a href="/documentation/jdbc/index.html">SPARQL over JDBC</a></li>
                        <li><a href="/documentation/permissions/index.html">Permissions</a></li>
                        <li><a href="/documentation/assembler/index.html">Assembler</a></li>
                        <li><a href="/documentation/ontology/">Ontology API</a></li>
                        <li><a href="/documentation/inference/index.html">Inference API</a></li>
                        <li><a href="/documentation/extras/querybuilder/index.html">Query Builder</a></li>
                    </ul>
                </li>

                <li class="drop down">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown"><span class="glyphicon glyphicon-book"></span> Javadoc <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/documentation/javadoc/jena/">Jena Core</a></li>
                        <li><a href="/documentation/javadoc/arq/">ARQ</a></li>
                        <li><a href="/documentation/javadoc/tdb/">TDB</a></li>
                        <li><a href="/documentation/javadoc/fuseki2/">Fuseki</a></li>
                        <li><a href="/documentation/javadoc_elephas.html">Elephas</a></li>
                        <li><a href="/documentation/javadoc/text/">Text Search</a></li>
                        <li><a href="/documentation/javadoc/shacl/">SHACL</a></li>
                        <li><a href="/documentation/javadoc/geosparql/">GeoSPARQL</a></li>
                        <li><a href="/documentation/javadoc/permissions/">Permissions</a></li>
                        <li><a href="/documentation/javadoc/jdbc/">JDBC</a></li>
                        <li><a href="/documentation/javadoc/extras/querybuilder/">Query Builder</a></li>
                        <li><a href="/documentation/javadoc.html">All Javadoc</a></li>
                    </ul>
                </li>

                <li id="ask"><a href="/help_and_support/index.html"><span class="glyphicon glyphicon-question-sign"></span> Ask</a></li>

                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown"><span class="glyphicon glyphicon-bullhorn"></span> Get involved <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/getting_involved/index.html">Contribute</a></li>
                        <li><a href="/help_and_support/bugs_and_suggestions.html">Report a bug</a></li>
                        <li class="divider"></li>
                        <li class="dropdown-header">Project</li>
                        <li><a href="/about_jena/about.html">About Jena</a></li>
                        <li><a href="/about_jena/roadmap.html">Roadmap</a></li>
                        <li><a href="/about_jena/architecture.html">Architecture</a></li>
                        <li><a href="/about_jena/team.html">Project team</a></li>
                        <li><a href="/about_jena/contributions.html">Related projects</a></li>
                        <li class="divider"></li>
                        <li class="dropdown-header">ASF</li>
                        <li><a href="http://www.apache.org/">Apache Software Foundation</a></li>
                        <li><a href="http://www.apache.org/licenses/LICENSE-2.0">License</a></li>
                        <li><a href="http://www.apache.org/foundation/thanks.html">Thanks</a></li>
                        <li><a href="http://www.apache.org/foundation/sponsorship.html">Become a Sponsor</a></li>
                        <li><a href="http://www.apache.org/security/">Security</a></li>
                    </ul>
                </li>

                <li id="edit"><a href="https://github.com/apache/jena-site/edit/main/source/documentation/notes/sse.md" title="Edit this page on GitHub"><span class="glyphicon glyphicon-pencil"></span> Edit this page</a></li>
            </ul>
        </div>
    </div>
</nav>


<div class="container">
    <div class="row">
        <div class="col-md-12">
            <div id="breadcrumbs">
                
                    





<ol class="breadcrumb">
    
    
        
        
    
        
        
            
                <li><a href='/documentation'>DOCUMENTATION</a></li>
            
            
        
    
        
        
            
                <li><a href='/documentation/notes'>NOTES</a></li>
            
            
        
    
        
        
            
                <li class="active">SSE</li>
            
            
        
    
</ol>




                
            </div>
            <h1 class="title">SPARQL S-Expressions (or &#34;SPARQL Syntax Expressions&#34;)</h1>
            
	<p>A way to write down data structures in an RDF-centric syntax.</p>
<p>But not an idea for another RDF serialization format.</p>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#need">Need</a></li>
<li><a href="#design-intent">Design Intent</a></li>
<li><a href="#other-approaches">Other Approaches</a>
<ul>
<li><a href="#rdf">RDF</a></li>
<li><a href="#lisp">Lisp</a></li>
<li><a href="#xml">XML</a></li>
<li><a href="#json">JSON</a></li>
</ul>
</li>
<li><a href="#design">Design</a>
<ul>
<li><a href="#tokens">Tokens</a></li>
<li><a href="#sse-comments">SSE Comments</a></li>
<li><a href="#sse-escapes">SSE Escapes</a></li>
<li><a href="#structures">Structures</a></li>
</ul>
</li>
<li><a href="#tagged-structures">Tagged Structures</a>
<ul>
<li><a href="#iri-resolution">IRI resolution</a>
<ul>
<li><a href="#base">base</a></li>
<li><a href="#prefix">prefix</a></li>
<li><a href="#nesting">Nesting</a></li>
</ul>
</li>
<li><a href="#links">Links</a></li>
</ul>
</li>
<li><a href="#building-java-objects">Building Java Objects</a>
<ul>
<li><a href="#sse-factory">SSE Factory</a></li>
</ul>
</li>
<li><a href="#mapping-to-rdf">Mapping to RDF</a></li>
<li><a href="#sse-files">SSE Files</a></li>
<li><a href="#longer-examples">Longer Examples</a>
<ul>
<li><a href="#query-1">Query 1</a></li>
<li><a href="#complete-sparql-execution">Complete SPARQL Execution</a></li>
</ul>
</li>
<li><a href="#sse-grammar">SSE Grammar</a></li>
</ul>
<h2 id="need">Need</h2>
<p>The <a href="http://www.w3.org/TR/sparql11-query/#sparqlAlgebra">SPARQL algebra</a>
defines the semantics of a SPARQL graph pattern. Every SPARQL query
string (the syntax) is mapped to a SPARQL algebra expression.</p>
<p>It is convenient to be able to print out such algebra expressions for
discussion between people and for debugging. Further, if algebra
expressions can be read back in as well, testing of specific parts of an
implementation is also easier.</p>
<p>This is an example of a general problem : how to express data structures
where the basic elements of RDF are based on RDF nodes.</p>
<p>RDF itself is often the most appropriate way to do this, but sometimes
it isn&rsquo;t so convenient. An algebra expression is a tree, and order
matters.</p>
<p>When expressing a data structure, there are certain key structure that
need to be expressible: arrays and maps, then sets and bags, but
expression of a data structure is not the same as the high-level
semantics of the data structure.</p>
<p>A stack can be expressed as a list. And because we want to express the
structure, and not express the operations on the structures, data
structures with operational meaning don&rsquo;t enter the picture. There are
no operations, no <em>push</em>, <em>pop</em> or <em>peek</em>.</p>
<p>Note that this is to <em>express</em> a data structure, not <em>encode</em> or
<em>represent</em> it. By <em>express</em> we mean communicate it, between people or
between cooperating machines. The structures are not completely
self-representing. But we do discuss a way to express in RDF that does
give a self-describing nature through the use of tagged structures.</p>
<h2 id="design-intent">Design Intent</h2>
<ul>
<li>Concise (=&gt; for people to write conveniently) format for data
structures</li>
<li>RDF-centric</li>
</ul>
<p>Non-goals:</p>
<ul>
<li>to directly represent any data structure.</li>
<li>to be another RDF syntax.</li>
</ul>
<p>So desirable features are:</p>
<ul>
<li>Concise syntax for RDF terms</li>
<li>Datastructures</li>
</ul>
<h2 id="other-approaches">Other Approaches</h2>
<h3 id="rdf">RDF</h3>
<p>RDF is &ldquo;map-centric&rdquo; but not all data structures are conveniently
expressible in maps. RDF has lists, and these lists have convenient
syntax in Turtle or N3.</p>
<p>If your data structure fits the RDF paradigm, then RDF is a better
choice that SSE. <a href="#mapping-to-rdf">Below</a> is a possible mapping from SSE
to RDF as Turtle.</p>
<h3 id="lisp">Lisp</h3>
<p>Lacks convenient syntax for the RDF terms themselves.</p>
<p>SSE syntax is almost valid
<a href="http://www.schemers.org" title="http://www.schemers.org">Scheme</a>; literal
language tags and datatypes get split a separate list symbols but the
information is recoverable. Scheme doesn&rsquo;t use <code>[]</code> lists or
single-quoted strings.</p>
<h3 id="xml">XML</h3>
<p>Too verbose.</p>
<h3 id="json">JSON</h3>
<p><a href="http://json.org/" title="http://json.org/">JSON</a> provides values (strings,
numbers, booleans, null), arrays and object (which are maps). <a href="http://www.w3.org/TR/rdf-sparql-json-res/" title="http://www.w3.org/TR/rdf-sparql-json-res/">SPARQL
Query Results in
JSON</a>
shows how JSON might be used. It describes how RDF terms are encoded
into further substructures. Alternatively, we could put encoded terms in
strings like &ldquo;<a href="http://w3.org/%5C">http://w3.org/\</a>&rdquo; and have a parser-within-a-parser. But
both these approaches do not make the writing of RDF terms as easy as it
could be.</p>
<h2 id="design">Design</h2>
<p><a href="http://en.wikipedia.org/wiki/S-expression" title="http://en.wikipedia.org/wiki/S-expression">S-expressions</a>
using RDF terms.</p>
<p>The command <code>arq.qparse --print=op --file queryFile</code> will print the
SPARQL algebra for the query in SSE format.</p>
<h3 id="tokens">Tokens</h3>
<p>Tokens are the atomic elements of the syntax.</p>
<table>
<thead>
<tr>
<th>Example</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;abc&quot;</code></td>
<td>string</td>
</tr>
<tr>
<td><code>&quot;abc&quot;@en</code></td>
<td>string with language tag.</td>
</tr>
<tr>
<td><code>123</code></td>
<td>number, specifically an xsd;integer.</td>
</tr>
<tr>
<td><code>&lt;http://example.org/&gt;</code></td>
<td>IRI (or URI).</td>
</tr>
<tr>
<td><code>_:abc</code></td>
<td>blank node.</td>
</tr>
<tr>
<td><code>?x</code></td>
<td>variable</td>
</tr>
<tr>
<td><code>?</code></td>
<td>variable</td>
</tr>
<tr>
<td><code>ex:thing</code></td>
<td>prefixed name</td>
</tr>
<tr>
<td><code>ex:123</code></td>
<td>prefixed name</td>
</tr>
<tr>
<td><code>SELECT</code></td>
<td>symbol</td>
</tr>
<tr>
<td><code>+</code></td>
<td>symbol</td>
</tr>
<tr>
<td><code>@xyz</code></td>
<td>symbol</td>
</tr>
</tbody>
</table>
<p>For <code>?</code> (no name), a unique, internal name for a fresh variable will be
allocated; every use of <code>?</code> is a different variable.</p>
<p><code>??x</code> creates a non-distinguished variable. <code>??</code> creates a fresh
non-distinguished variable.</p>
<p><code>_:</code> creates a fresh blank node.</p>
<p><code>@xyz</code> - this is a symbol because a language tags only follow a lexical
form.</p>
<p>Almost any sequence of characters which is not an RDF term or variable
is a symbol that can be given special meaning by processing software.</p>
<h3 id="sse-comments">SSE Comments</h3>
<p><code>#</code> or <code>;</code> introduce comments, which run to the end of line, including
the end-of-line characters.</p>
<h3 id="sse-escapes">SSE Escapes</h3>
<p><code>\u</code> and <code>\U</code> escape sequences for arbitrary Unicode codepoints. These
apply to the input character stream before parsing. They don&rsquo;t, for
example, permit a space in a symbol.</p>
<p>Strings provide <code>\n</code>, <code>\t</code>, <code>\r</code>, <code>\b</code>, <code>\b</code>, <code>\f</code>, <code>\&quot;</code>, <code>\'</code> and <code>\\</code>
escape sequences as in SPARQL.</p>
<h3 id="structures">Structures</h3>
<p><code>(?x ns:p &quot;abc&quot;)</code> - list of 3 elements: a variable, a prefixed name and
a string</p>
<pre><code>(bgp 
  [?x ns:p &quot;abc&quot;])
</code></pre>
<p>A list of 2 elements: a symbol (<code>bgp</code>) and a list of 3 elements. Both
<code>()</code> and <code>[]</code> delimit lists; they must match but otherwise it&rsquo;s a free
choice. Convention is that compact lists use <code>[]</code>; large lists use <code>()</code>.</p>
<h2 id="tagged-structures">Tagged Structures</h2>
<p>The basic syntax defines tokens and lists. Higher level processing
happens on this basic syntax and can be extended by interpreting the
structure.</p>
<p>Layers on top of the basic abstract syntax produce specialised data
structures. This can be a transformation into a new SSE structure or the
production of programming language objects.</p>
<p>This is driven by tagged (data) objects in an SSE expression. The tag is
a symbol and the elements of the data object are the rest of the list.</p>
<pre><code>(+ 1 2)
</code></pre>
<p>is tagged with symbol <code>+</code></p>
<pre><code>(triple ?s ?p &quot;text&quot;@en)
</code></pre>
<p>is tagged with symbol <code>triple</code></p>
<h3 id="iri-resolution">IRI resolution</h3>
<p>One such layer is IRI and prefix name resolution, using tags <code>base</code> and
<code>prefix</code>.</p>
<p>Basic syntax includes unresolved IRIs, (example <code>&lt;abc&gt;</code>) and prefixed
names (example <code>foaf:name</code>). These are turned into absolute IRIs and the
<code>base</code> and <code>prefix</code> tagged object wrappers are removed.</p>
<p>This is sufficiently important that the SSE library handles this in an
optimized fashion where the IRI processing directly rewrites the
streamed output of the parser.</p>
<h4 id="base"><code>base</code></h4>
<pre><code>(base &lt;http://example/&gt;
   (triple &lt;xyz&gt; ?p &quot;lex&quot;^^&lt;thing&gt;))
</code></pre>
<p>becomes</p>
<pre><code>(triple &lt;http://example/xyz&gt; ?p &quot;lex&quot;^^&lt;http://example/thing&gt;)
</code></pre>
<h4 id="prefix"><code>prefix</code></h4>
<pre><code>(prefix ((: &lt;http://example/&gt;)
          (ns: &lt;http://example/ns#&gt;))
     (triple :x ns:p &quot;lex&quot;^^ns:type))
</code></pre>
<p>becomes</p>
<pre><code> (triple &lt;http://example/x&gt; &lt;http://example/ns#p&gt; &quot;lex&quot;^^&lt;http://example/ns#type&gt;)
</code></pre>
<h4 id="nesting">Nesting</h4>
<p>The tagged structures can be combined and nested. The base or prefixes
declared only apply to the body of the data object.</p>
<pre><code> (prefix ((: &lt;http://jena.hpl.hp.com/2007/&gt;)
             (foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;))
       (triple (base &lt;http://jena.hpl.hp.com/&gt; &lt;afs&gt; foaf:name &quot;Andy&quot;)))
</code></pre>
<p>Combined with the triple builder, this will produce a triple:</p>
<pre><code> &lt;http://jena.hpl.hp.com/afs&gt; &lt;http://xmlns.com/foaf/0.1/name&gt; &quot;Andy&quot; .
</code></pre>
<h3 id="links">Links</h3>
<p><em>Not implemented</em></p>
<p>Not all data structures can be conveniently expressed as nested lists.
Sub-element sharing matters. A structure with shared elements can&rsquo;t be
serialized as a strict tree and some form of reference is needed.</p>
<p>Name a place in the structure: <code>(name@ symbol X)</code></p>
<p>Link to it: <code>(@link symbol)</code></p>
<p>The link layer will produce an SSE structure without these tags, having
replaced all <code>name@</code> and <code>@link</code> with the shared structure <em>X</em>.</p>
<p><em><code>@</code> is a convention for referencing.</em></p>
<h2 id="building-java-objects">Building Java Objects</h2>
<p>Builders are code classes that process the structure into Java objects.
Writing builders is straight-forward because low-level parsing details
have been taken care of in the basic syntax. A typical builder is a
recursive-decent parser over the abstract syntax tree, coding one is
primarily walking the structure, with a tagged object to Java instance
mapping being applied.</p>
<p>Some tagged objects with builders are:</p>
<ul>
<li><code>(triple S P O)</code> where <em>X</em> is an RDF node (RDF term or variable).</li>
<li><code>(quad G S P O)</code></li>
<li><code>(graph triple*)</code></li>
<li><code>(graph@ URL)</code> â€” Read a URL.</li>
</ul>
<p><em>@@ Need to write the abstract syntax for each tagged object</em></p>
<p>Many builders have convenience syntax. Triples can be abbreviated by
omitting the tag <code>triple</code> because usually the fact it is a triple is
clear.</p>
<pre><code>(bgp (triple ?s ?p ?o)) 
(bgp (?s ?p ?o)) 
</code></pre>
<p>Quads have a similar abbreviation as 4-lists. In addition, <code>_</code> is a quad
on the default graph.</p>
<p>Elements for executing SPARQL:</p>
<ul>
<li>SPARQL algebra operators and basic graph patterns</li>
<li>Filter expressions (in prefix notation <code>(+ 1 2)</code>)</li>
<li>Query solutions (Bindings) and tables.</li>
</ul>
<h3 id="sse-factory">SSE Factory</h3>
<p>The class <code>SSE</code> in package <code>org.apache.jena.sparql.sse</code> provides many
convenience functions to call builders for RDF and SPARQL structures.</p>
<pre><code>Node n = SSE.parseNode(&quot;&lt;http://example/node&gt;&quot;) ;
Triple t = SSE.parseTriple(&quot;(?s ?p ?o)&quot;) ;
Op op = SSE.parseOp(&quot;(filter (&gt; ?v 123) (bgp (?s ?p ?v)))&quot;) ;
</code></pre>
<p>Most of the operations have forms that allow a <code>PrefixMapping</code> to be
specified - this is wrapped around the parser run so prefixed names can
be used without explicit prefix declarations.</p>
<p>There is a default prefix mapping with a few common prefixes: <code>rdf</code>,
<code>rdfs</code>, <code>owl</code>, <code>xsd</code> and <code>fn</code> (the XPath/XQuery functions and operators
namespace).</p>
<h2 id="mapping-to-rdf">Mapping to RDF</h2>
<p>The syntax of SSE is very close to Turtle lists because the syntax for
IRIs and literals are the same.: to produce Turtle (outline):</p>
<ol>
<li>Replace symbols by IRIs: prepend a common URI and %-encode any
characters necessary.</li>
<li>Replace variables by IRIs: prepend a common URI.</li>
<li>Move prefixes to be <code>@prefix</code> directives.</li>
<li>Put a dot at the end of the file.</li>
</ol>
<p>The result is an RDF model using only the properties <code>rdf:first</code> and
<code>rdf:rest</code> so it records the data structure, but not what the data
structure represents.</p>
<h2 id="sse-files">SSE Files</h2>
<p>The file extension is <code>.sse</code> and all files are UTF-8.</p>
<p>A quick and pragmatic Emacs mode is given by:</p>
<pre><code>;; ==== SSE mode
(define-derived-mode sse-mode lisp-mode &quot;SSE&quot; nil
   (make-local-variable 'lisp-indent-function)
   (setq lisp-indent-function 'sse-indent-function)
   )

;; Everything in SSE is &quot;def&quot; like
(defun sse-indent-function (indent-point state)
  (lisp-indent-defform state indent-point))

(setq auto-mode-alist
       (cons '(&quot;\\.sse&quot; . sse-mode) auto-mode-alist))
</code></pre>
<h2 id="longer-examples">Longer Examples</h2>
<h3 id="query-1">Query 1</h3>
<pre><code>PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT DISTINCT ?name ?nick
{
    ?x foaf:mbox &lt;mailt:person@server&gt; .
    ?x foaf:name ?name 
    OPTIONAL { ?x foaf:nick ?nick }
}

(prefix ((foaf: &lt;http://xmlns.com/foaf/0.1/&gt;))
   (distinct
     (project (?name ?nick)
       (leftjoin
         (BGP
           [triple ?x foaf:mbox &lt;mailto:person@server&gt;]
           [triple ?x foaf:name ?name]
         )
         (BGP [triple ?x foaf:nick ?nick])
       ))))
</code></pre>
<h3 id="complete-sparql-execution">Complete SPARQL Execution</h3>
<p>The following is a complete query execution, data and query. There is an
inline dataset and a query of</p>
<pre><code> PREFIX : &lt;http://example/&gt;
 SELECT * 
 {
   GRAPH :g1 { ?x ?p ?v }
 }
</code></pre>
<p>The tag <code>graph</code> is used twice, with different meanings. First, for an
RDF graph, and second in <code>GRAPH</code> SPARQL pattern. In a data structure,
context sorts out the different usages.</p>
<pre><code>(prefix ((: &lt;http://example/&gt;))
   (exec
     (dataset
       (default (graph
          (:x :p 1)
          (:x :p 2)))
       (namedgraph :g1
     (graph
       (:x :gp 1)
       (:x :gp 2)))
       (namedgraph :g2
     (graph
       (:y :gp 1)
       (:y :gp 2)))
       )

     (graph :g1
       (bgp (?x ?p ?v)))
     ))
</code></pre>
<h2 id="sse-grammar">SSE Grammar</h2>
<p><em>@@ insert grammar here</em></p>


        </div>
    </div>

</div>

<footer class="footer">
    <div class="container">
        <p>
            Copyright &copy; 2011&ndash;2021 The Apache Software Foundation, Licensed under the
            <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.
        </p>
        <p>
            Apache Jena, Jena, the Apache Jena project logo, Apache and the Apache feather logos are trademarks of
            The Apache Software Foundation.
        </p>
    </div>
</footer>


<script type="text/javascript">
    var link = $('a[href="' + this.location.pathname + '"]');
    if (link != undefined)
        link.parents('li,ul').addClass('active');
</script>

</body>
</html>
